hello
*6m51CSy#WBy


this is forums/models.py, currently it uses the user id from the django superuser account to add categories and post. I want to make it so that it uses the pyjwt access token stored in the local storage. I'm using django and vue.js.
```from django.db.models import CharField, TextField, Model, ForeignKey, URLField, IntegerField, ManyToManyField
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from autoslug import AutoSlugField
from model_utils.models import TimeStampedModel
from datetime import datetime, timedelta, timezone
from dateutil.relativedelta import relativedelta


class Category(TimeStampedModel):
    name = CharField(max_length=56, help_text='Enter category name')
    path = CharField(max_length=20, help_text='Enter category url path')
    slug = AutoSlugField(
        "category url slug",
        unique=True,
        always_update=False,
        populate_from="path")
    description = TextField("Category Description", blank=True)
    owner = ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=True)

    # Metadata
    class Meta:
        ordering = ['-slug']

    # Methods
    def get_absolute_url(self):
        return reverse('reddit:category', kwargs={'slug': self.slug})

    def __str__(self):
        return str(self.slug)


class Post(TimeStampedModel):
    title = CharField(max_length=32, help_text='Enter Post Title')
    description = TextField("Post Description", blank=True)
    owner = ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=False)
    category = ForeignKey(Category,
                        on_delete=models.CASCADE,
                        null=False)
    # image = models.ImageField(upload_to='images/', default='default.png')
    slug = AutoSlugField(
        "Post url slug",
        unique=True,
        always_update=False,
        populate_from="title")
    user_vote = 0
    user_up_style = ''
    user_down_style = ''

    # Metadata
    class Meta:
        ordering = ['-modified']

    # Methods
    def get_absolute_url(self):
        return reverse('reddit:post', kwargs={'slug': self.slug, 'category_slug': self.category_slug})

    def __str__(self):
        return self.title

    def get_category(self):
        return self.category.slug

    def get_full_url(self):
        return '/r/' + self.category.slug + '/' + self.slug

    def username(self):
        return self.owner.username

    def category_name(self):
        return self.category.name

    def time_since_post(self):
        e = ''
        if self.modified != self.created:
            e = '*'
        time_now = datetime.now(timezone.utc)
        diff_time = time_now - self.modified
        diff_days, diff_hours, diff_mins = str(diff_time.days), str(
            int(diff_time.seconds / 3600)), str(int(diff_time.seconds / 60))
        if diff_days == '0':
            if int(diff_mins) < 60:
                if diff_mins == '1':
                    return e+'1 minute ago.'
                return e+diff_mins + ' minutes ago.'
            if diff_hours == '1':
                return e+'1 hour ago'
            return e+diff_hours + ' hours ago.'
        if diff_days == '1':
            return e+'1 day ago.'
        return e+diff_days + ' days ago.'

    def owner_url(self):
        return '/users/' + self.owner.username

    def number_of_comments(self):
        return PostComment.objects.filter(post_id=self.id).count()

    def description_br(self):
        safe_text = self.description.replace('<', '').replace('>', '').replace(
            '{{', '').replace('{%', '').replace('}}', '').replace('%}', '')
        safe_text = safe_text.replace('((b))', '<strong>').replace(
            '((/b))', '</strong>').replace('((i))', '<i>').replace('((/i))', '</i')
        return "<br>".join(safe_text.splitlines())

    def score(self):
        votes = PostVotes.objects.filter(post_id=self.id)
        score = 0
        for vote in votes:
            score = score + vote.vote
        return score
    score = score

    def age_in_days(self):
        time_now = datetime.now(timezone.utc)
        diff_time = time_now - self.created
        days_since_post, secs_since_post = diff_time.days, diff_time.seconds
        days_since_post_float = secs_since_post / 86400 + days_since_post
        return days_since_post_float

    def weighted_score(self):
        if self.score() == 0:
            return 0
        time_now = datetime.now(timezone.utc)
        diff_time = time_now - self.created
        days_since_post, secs_since_post = diff_time.days, diff_time.seconds
        days_since_post_float = secs_since_post / 86400 + days_since_post
        return self.score() / days_since_post_float

    # def get_image(self):
    #     if self.image:
    #         return self.image.url
    #     return ''

    category_slug = get_category
    full_url = get_full_url


class PostVotes(Model):
    post_id = ForeignKey('Post', related_name='post', on_delete=models.CASCADE)
    user_id = ForeignKey(settings.AUTH_USER_MODEL,
                         on_delete=models.CASCADE, null=False)
    VOTE_CHOICES = [(-1, 'downvote'), (0, 'no vote'), (1, 'upvote')]
    vote = IntegerField(choices=VOTE_CHOICES, default=None)

    def up_color(self):
        if self.vote == 1:
            return 'orange'
        return 'grey'

    def down_color(self):
        if self.vote == -1:
            return 'blue'
        return 'grey'


class PostComment(TimeStampedModel):
    class Meta:
        ordering = ['-modified']
    post_id = ForeignKey('Post', related_name='comment_post',
                         on_delete=models.CASCADE, null=False)
    user_id = ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=False)
    comment = TextField("Post Comment", blank=True)
    user_vote = 0
    user_up_style = ''
    user_down_style = ''
    tldr = CharField(
        max_length=56, help_text="Too Long; Didn't Read. Your responce in a nutshell")
    parent = ForeignKey('PostComment', related_name='comment_reply',
                        on_delete=models.CASCADE, null=True, blank=True)

    def children(self):
        return self.comment_reply.all()

    def level(self):
        if self.parent:
            return self.parent.level() + 1
        return 0

    def username(self):
        return self.user_id.username

    def time_since_comment(self):
        time_now = datetime.now(timezone.utc)
        diff_time = time_now - self.modified
        diff_days, diff_hours = str(diff_time.days), str(
            int(diff_time.seconds / 3600))
        if diff_days == '0':
            if diff_hours == '1':
                return '1 hour ago'
            return diff_hours + ' hours ago.'
        else:
            if diff_days == '1':
                return '1 day ago.'
            return diff_days + ' days ago.'

    def owner_url(self):
        return '/users/' + self.user_id.username

    def comment_br(self):
        safe_text = self.comment.replace('<', '').replace('>', '').replace(
            '{{', '').replace('{%', '').replace('}}', '').replace('%}', '')
        safe_text = safe_text.replace('((b))', '<strong>').replace(
            '((/b))', '</strong>').replace('((i))', '<i>').replace('((/i))', '</i')
        return "<br>".join(safe_text.splitlines())

    def score(self):
        votes = PostVotes.objects.filter(post_id=self.id)
        score = 0
        for vote in votes:
            score = score + vote.vote
        return score

    def __str__(self):
        if len(self.comment) > 20:
            return self.comment[:20] + '...'
        return self.comment

    score = score```

these are the relevant front-end code:
component/PostBox.vue:
```<template>
    <div>
        <div class="post-box" v-show="!isHidden">
            <h3 class="post-box-title"><router-link :to="{ name: 'post-detail', params: { slug: post.slug } }">{{ post.title
            }}</router-link>
            </h3>
            <p class="post-box-description">{{ post.description }}</p>
            <div class="post-box-details">
                <div class="post-box-subreddit">
                    <i class="fas fa-rss"></i>
                    <span class="post-box-subreddit-name">{{ post.category_name }}</span>
                </div>
                <div class="post-box-score">


                </div>
                <div class="post-box-time">
                    <i class="far fa-clock"></i>
                    <span class="post-box-time-since">{{ post.time_since_post }}</span>
                </div>
            </div>
            <div>
                <div class="post-box-interactions">
                    <i class="fas fa-arrow-up post-box-upvote fa-xl" @click="upvote" :style="{ color: upColor }"></i>
                    <span>{{ post.score }}</span>
                    <i class="fas fa-arrow-down post-box-downvote fa-xl" @click="downvote"
                        :style="{ color: downColor }"></i>
                    <span style="margin-left: 10px;"><i class="fa-sharp fa-solid fa-comments fa-xl"></i><router-link
                            :to="{ name: 'post-detail', params: { slug: post.slug } }">&nbsp;{{ post.number_of_comments
                            }}Comments</router-link></span>
                    <i class="fa-sharp fa-solid fa-eye-slash fa-xl" v-on:click="isHidden = !isHidden"
                        style="margin-left: 10px;"></i>
                </div>
            </div>
        </div>
        <div v-show="isHidden">
            <div class="post-box">
                <div style="justify-content: center; display: flex;">
                    <i class="fa-solid fa-eye fa-xl" v-on:click="isHidden = !isHidden"></i>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
import { getAPI } from '@/plugins/axios';
import { reactive } from '@vue/reactivity';

export default {
    props: {
        post: {
            type: Object,
            required: true,
        },
    },
    data() {
        return {
            vote: 0,
            userVote: null,
            isHidden: false,
        };
    },
    computed: {
        totalScore() {
            // Calculate the total score based on the current vote and the existing votes from the API response.
            let score = this.post.score;
            if (this.userVote) {
                score -= this.userVote.vote;
            }
            score += this.vote;
            return score;
        },
        upColor() {
            return this.vote === 1 ? 'orange' : 'grey';
        },
        downColor() {
            return this.vote === -1 ? 'blue' : 'grey';
        },
    },
    created() {
        // Send a GET request to retrieve the user's existing vote for the post.
        getAPI.get(`/posts/${this.post.id}/votes/?user_id=1`)
            .then(response => {
                // If the user has already voted, extract the existing vote from the response data.
                const existingVote = response.data.find(vote => vote.post_id === this.post.id && vote.user_id === 1);

                if (existingVote) {
                    this.userVote = reactive(existingVote);

                    // Set the vote to the user's existing vote.
                    this.vote = existingVote.vote;
                }
            })
            .catch(error => {
                console.log(error);
            });
    },
    methods: {
        upvote() {
            // If the user has already upvoted, remove their vote.
            if (this.userVote && this.userVote.vote === 1) {
                this.vote = 0;
            } else {
                // If the user has already downvoted, switch their vote.
                if (this.userVote && this.userVote.vote === -1) {
                    this.vote = 1;
                } else {
                    // If the user hasn't voted yet or has removed their vote, upvote.
                    this.vote = 1;
                }
            }

            this.updateVote();
        },
        downvote() {
            // If the user has already downvoted, remove their vote.
            if (this.userVote && this.userVote.vote === -1) {
                this.vote = 0;
            } else {
                // If the user has already upvoted, switch their vote.
                if (this.userVote && this.userVote.vote === 1) {
                    this.vote = -1;
                } else {
                    // If the user hasn't voted yet or has removed their vote, downvote.
                    this.vote = -1;
                }
            }

            this.updateVote();
        },
        updateVote() {
            const data = {
                post_id: this.post.id,
                user_id: 1,
                vote: this.vote,
                id: this.userVote ? this.userVote.id : null,
            };

            if (data.id) {
                // If the user has already voted, make a PUT request to update the existing vote.
                getAPI.put(`/posts/${this.post.id}/votes/${this.userVote.id}/`, data)
                    .then(response => {
                        console.log(response.data);
                        this.userVote = reactive(response.data);
                    })
                    .catch(error => {
                        console.log(error);
                    });
            } else {
                // If the user hasn't voted yet, make a POST request to create a new vote.
                getAPI.post(`/posts/${this.post.id}/votes/`, data)
                    .then(response => {
                        console.log(response.data);
                        this.userVote = reactive(response.data);
                    })
                    .catch(error => {
                        console.log(error);
                    });
            }
        },
    },
};

</script>
```

views/PostCreate.vue:
```<template>
    <div class="post">
        <h1>Create a Post</h1>
        <form @submit.prevent="handleSubmit">
            <input class="input" id="title" v-model="title" type="text" required placeholder="Title">
            <br>
            <textarea class="description" id="description" v-model="description" placeholder="Description"
                rows="10"></textarea>
            <br>
            <div class="bottom">
                <button type="submit">Create Post</button>
                <br>
                <select class="category" id="category" v-model="category" required>
                    <option value="" disabled>Category</option>
                    <option v-for="category in categories" :value="category.id" :key="category.id">{{ category.name }}
                    </option>
                </select>
            </div>
        </form>
    </div>
</template>
  
<script>
import { getAPI } from '@/plugins/axios';

export default {
    data() {
        return {
            title: '',
            description: '',
            owner: '',
            category: '',
            categories: [],
        };
    },
    mounted() {
        this.fetchCategories();
    },
    methods: {
        fetchCategories() {
            getAPI.get('/categories/')
                .then(response => {
                    this.categories = response.data;
                })
                .catch(error => {
                    console.log(error);
                });
        },
        handleSubmit() {
            const payload = {
                title: this.title,
                description: this.description,
                category: this.category,
                owner: 1,
            };
            getAPI
                .post('/posts/', payload).then(() => {
                    alert('Post created successfully!');
                    this.$router.push('/'); // Redirect to homepage or wherever you want
                }).catch((error) => {
                    console.log(error);
                });
        },
    },
};
</script>

<style>
@import url('./../assets/PostCreate.css');
</style>
```

views/PostsList.vue:
```<template>
    <div class="left">
        <div class="sidebar">
            <p>hello</p>
        </div>
        <router-link to="/create">
            <div class="create">
                New Post
            </div>
        </router-link>
    </div>
    <div class="post-background">
        <h2 style="color: black; margin-bottom: 10px;">Posts</h2>
        <div v-for="post in allposts" :key="post.id">
            <post-box :post="post" />
            <vote :post-id="post.id" :initial-score="post.score"></vote>
        </div>
    </div>
</template>

<script>
import { getAPI } from '@/plugins/axios';
import PostBox from '../components/PostBox.vue';
import { mapState } from 'vuex';

export default {
    name: 'PostsList',
    components: {
        'post-box': PostBox,
    },
    data() {
        return {
            allposts: [],
        }
    },
    computed: mapState(['APIData']),
    created() {
        getAPI.get('/allposts/')
            .then(response => {
                console.log("Post API has received data")
                this.allposts = response.data
            })
            .catch(error => {
                console.log(error)
            })
    }
}
</script>
```